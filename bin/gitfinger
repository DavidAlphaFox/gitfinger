#!/usr/bin/env ruby

require 'time'
require 'octokit'
require 'yaml'
require 'optparse'

opts = {}
op = OptionParser.new {|o|
  o.banner = "Usage: gitfinger [GitHub username]"
  o.separator ""
  o.separator "Specific options:"
  o.on("-s", "--sort [FIELD]", "Order on FIELD") { |field| opts[:sort] = field }
  o.on("-r", "--reverse", "Reverse standard order") { opts[:reverse] = true }
  o.on("-h", "--help", "Show this message") { 
    require 'gitfinger'
    puts "gitfinger #{Gitfinger::VERSION}"
    puts o 
    exit
  }
  o.on("-v", "--version", "Show version") { 
    require 'gitfinger'
    puts "gitfinger #{Gitfinger::VERSION}"
    exit
  }
}
op.parse!
user = ARGV.first 
if user.nil?
  $stderr.puts op
  exit 1
end

c = Octokit::Client.new 

begin
  repos = c.repositories(user, per_page: 300)
rescue Octokit::NotFound
  $stderr.puts "GitHub user #{user} not found"
  exit 1
end

def truncate(s, len)
  return unless s
  s.length > len ? s[0,len-3] + '...' : s
end

res = repos.map {|r|
  d = %w( repo name w watchers f forks i open_issues updated updated_at pushed pushed_at type fork desc description).each_slice(2).reduce({}) {|m, (display_key,api_key)|
    m[display_key] = r[api_key]
    m
  }
  %w( updated pushed ).each {|x| d[x] = d[x] && DateTime.parse(d[x]) }
  d['type'] = d['type'] ? 'fork' : 'source'
  d
}

sort_field =  opts[:sort] || 'updated' 
res = res.sort_by {|x| 
  sort_value = x[sort_field] 
  if sort_value.nil? 
    sort_value = Time.at(0).to_date if sort_field =~ /updated|pushed/
    sort_value = "" if sort_field =~ /desc/
  end
  sort_value.downcase! if sort_field == 'repo'
  sort_value
}

# default order for date and counts is latest or greatest first
res.reverse! if %w(updated pushed w i f).member?(sort_field)
res.reverse! if opts[:reverse]

def fmt_datetime(t)
  t.strftime("%b %d %Y")
end

abort "No repositories found for #{user}" unless !res.empty?

longest_name_len = res.reduce(0) {|max, row| [max, row['repo'].length].max }

placeholders = "%#{longest_name_len}s%6s%5s%4s%13s%13s%9s  "
desc_length = `tput cols`.to_i - (placeholders.scan(/\d+/).map(&:to_i).reduce(0){|sum,x| sum+x} + 3)
placeholders += "%-#{desc_length}s"

# print headers
puts placeholders % res[0].keys

res.each {|r|
  %w( updated pushed ).each {|x| r[x] = r[x] && fmt_datetime(r[x]) }
  r['desc'] = truncate(r['desc'], desc_length)
  begin
    puts placeholders % r.values
  rescue Errno::EPIPE
    break
  end

}
